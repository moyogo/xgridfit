<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<title>Xgridfit</title>
<link rel="stylesheet" href="oeg.css" media="screen" type="text/css" />
<link rel="stylesheet" href="parchment.css" media="screen"
          type="text/css" title="parchment" />
<link rel="alternate stylesheet" href="legible.css" media="screen"
          type="text/css" title="legible" />
<style type="text/css" media="print"> @import "oeg.print.css"; </style>
<meta name="AUTHOR" content="Peter S. Baker" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

<div id="jumplist">
      <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=159705&amp;type=4" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a>
      <a href="http://xgridfit.sourceforge.net/">Home Page</a>
      <a href="http://sourceforge.net/projects/xgridfit">Project Page</a>
      <a href="http://sourceforge.net/project/showfiles.php?group_id=159705">Download</a>
      <a href="http://xgridfit.cvs.sourceforge.net/xgridfit/xgridfit/">CVS repository</a>
</div>

<div id="content">

  <h1>Tutorial 3: Working with FontForge auto-instructions</h1>
  <p>
    The easiest way to invoke the FontForge auto-instructor in the
    context of an Xgridfit program is
    with <a href="merge-mode.html">merge-mode</a>. It is also possible
    to copy and revise instructions generated by the auto-instructor.
    Here is a practical example drawn
    from <a href="http://junicode.sourceforge.net">Junicode
    Regular</a>, in which <b>b</b> is instructed "by hand,"
    while <b>uni0180</b> (<b>bbar</b>) has been auto-instructed.
  </p>
  <p>
    Although the outlines of <b>b</b> and <b>uni0180</b> are exactly the
    same except for the bar, the instructed versions of these glyphs
    look rather different at 20 ppem:
  </p>
  <table>
    <tr>
      <td>
	<img alt="hand-instructed b" src="b-hinted.png"/>
      </td>
      <td>
	<img alt="bbar auto-instructed" src="bbar-hinted.png"/>
      </td>
    </tr>
  </table>
  <p>
    There are various subtle differences here, but the obvious ones
    are that the top of the bowl is thicker and higher in <b>uni0180</b>
    than in <b>b</b> and that <b>uni0180</b> is narrower. If we can
    change these things, the two glyphs will match reasonably well.
  </p>
  <p>
    The first step is to get a copy of the program for <b>uni0180</b>.
    The easiest way to do so is to run a little Xgridfit utility,
    <tt>getinstrs</tt>, against a .ttf or .sfd file containing the
    glyph with its instructions (the <tt>--xgridfit</tt> option
    ensures that we end up with a complete, valid Xgridfit file):
  </p>
  <pre>
    getinstrs --xgridfit Junicode-Regular.ttf uni0180 &gt; uni0180.xgf</pre>
  <p>
    Now we're ready to edit the instructions.  Here is the program, in
    which we have identified the problem areas by running the
    FontForge TrueType debugger. We've inserted comments to mark the
    places:
  </p>
  <pre>
&lt;?xml version="1.0"?&gt;
&lt;xgridfit xmlns="http://xgridfit.sourceforge.net/Xgridfit2"&gt;
  &lt;glyph ps-name="uni0180" xml:id="uni0180" init-graphics="no"&gt;
    &lt;command name="SVTCA" modifier="y-axis"/&gt;
    &lt;push&gt;3 1 0&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;9&lt;/push&gt;
    &lt;command name="SHP" modifier="rp1"/&gt;
    &lt;push&gt;60&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
    &lt;push&gt;27 3 0&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;24&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
    &lt;push&gt;27 24 10&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;64 27 31 9&lt;/push&gt;
    &lt;command name="CALL"/&gt;
<b>&lt;!-- top of bowl --&gt;</b>
    &lt;push&gt;42 52 3 31 13&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;42&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
    &lt;push&gt;42 52 10&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;64 42 46 9&lt;/push&gt;
    &lt;command name="CALL"/&gt;
<b>&lt;!-- end top of bowl --&gt;</b>
    &lt;push&gt;20 17 3 31 13&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;38&lt;/push&gt;
    &lt;command name="SHP" modifier="rp1"/&gt;
    &lt;push&gt;20&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
    &lt;push&gt;34&lt;/push&gt;
    &lt;command name="SHP" modifier="rp2"/&gt;
    &lt;command name="SVTCA" modifier="x-axis"/&gt;
    &lt;push&gt;63&lt;/push&gt;
    &lt;command name="MDAP" modifier="rnd"/&gt;
    &lt;push&gt;15&lt;/push&gt;
    &lt;command name="MDRP" modifier="rp0,rnd,white"/&gt;
    &lt;push&gt;21&lt;/push&gt;
    &lt;command name="SHP" modifier="rp2"/&gt;
    &lt;push&gt;57&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
    &lt;push&gt;32 39&lt;/push&gt;
    &lt;command name="SHP" modifier="rp2"/&gt;
    &lt;command name="SHP" modifier="rp2"/&gt;
    &lt;push&gt;57 15 10&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;64 57 37 9&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;15 57 10&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;64 15 26 9&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;64 15 19 9&lt;/push&gt;
    &lt;command name="CALL"/&gt;
<b>&lt;!-- width of character --&gt;</b>
    &lt;push&gt;57&lt;/push&gt;
    &lt;command name="SRP0"/&gt;
    &lt;push&gt;49 1&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;0&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
<b>&lt;!-- end width of character --&gt;</b>
    &lt;push&gt;64 1&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;57 15&lt;/push&gt;
    &lt;command name="SRP1"/&gt;
    &lt;command name="SRP2"/&gt;
    &lt;push&gt;7 10 30&lt;/push&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="IP"/&gt;
    &lt;push&gt;49&lt;/push&gt;
    &lt;command name="SRP1"/&gt;
    &lt;push&gt;6 3 46&lt;/push&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="SVTCA" modifier="y-axis"/&gt;
    &lt;push&gt;60 3&lt;/push&gt;
    &lt;command name="SRP1"/&gt;
    &lt;command name="SRP2"/&gt;
    &lt;push&gt;6 13&lt;/push&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="IP"/&gt;
    &lt;push&gt;52&lt;/push&gt;
    &lt;command name="SRP1"/&gt;
    &lt;push&gt;0&lt;/push&gt;
    &lt;command name="IP"/&gt;
    &lt;command name="IUP" modifier="y"/&gt;
    &lt;command name="IUP" modifier="x"/&gt;
  &lt;/glyph&gt;
&lt;/xgridfit&gt;</pre>
  <p>
    The FontForge code looks a little obscure because it does much of
    its work by making calls to a library of functions, which the
    auto-instructor inserts into every font. (These well-crafted
    functions may also be of interest to Xgridfit programmers. You can
    get access to them via the macros defined in
    <tt>ff-functions.xgf</tt>, found in the <tt>utils</tt>
    subdirectory of the Xgridfit directory tree). However, it is not
    really necessary to understand the function calls to see in
    general terms what the auto-instructor is doing.
  </p>
  <p>
    We'll start by defining some constants for point numbers: first
    the two points that define the top and inside top of the bowl, and
    next some key points for the straight stem on the left of the
    glyph and the round stem on the right:
  </p>
  <pre>
    &lt;constant name="bowl-top" value="46"/&gt;
    &lt;constant name="bowl-top-inside" value="52"/&gt;
    &lt;constant name="left-left" value="15"/&gt;
    &lt;constant name="left-right" value="57"/&gt;
    &lt;constant name="right-right" value="0"/&gt;
    &lt;constant name="right-left" value="49"/&gt;</pre>
  <table>
    <tr>
      <td>
	<img alt="bbar auto-instructed" src="bbar-points.png"/>
      </td>
    </tr>
  </table>
  <p>
    The next step is to notice how the Junicode <b>b</b> is
    instructed. There, <tt>bowl-top</tt> is positioned at the x-height
    with a control value (<tt>lc-x-height</tt>), and the distance
    between <tt>bowl-top</tt> and <tt>bowl-top-inside</tt> is
    regulated with another control value
    (<tt>lc-horz-thin-curve</tt>). We'll comment out the offending
    instructions and replace them with Xgridfit code that employs the
    same control values:
  </p>
  <pre>
    &lt;move distance="lc-x-height"&gt;
      &lt;point num="bowl-top"/&gt;
      &lt;move distance="lc-horz-thin-curve"&gt;
	&lt;point num="bowl-top-inside"/&gt;
      &lt;/move&gt;
    &lt;/move&gt;
&lt;!-- top of bowl
    &lt;push&gt;42 52 3 31 13&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;42&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
    &lt;push&gt;42 52 10&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;64 42 46 9&lt;/push&gt;
    &lt;command name="CALL"/&gt;
--&gt;</pre>
  <p>
    Next, the FontForge auto-instructor has instructed along the
    x-axis by first positioning <tt>left-left</tt>, then
    <tt>left-right</tt> relative to that, then <tt>right-left</tt>,
    then <tt>right-right</tt>. In other words, it has gone strictly
    left-to-right. The Junicode <b>b</b> is instructed in a different
    order: first the left stem is regulated, then the overall width of
    the glyph (<tt>left-left</tt> to <tt>right-right</tt>, with a
    control value), and finally the right stem. We can approximate
    this behavior in revising the FontForge instructions (we'll ignore
    the width of the left stem for now):
  </p>
  <pre>
    &lt;move distance="bpq-char-width"&gt;
      &lt;reference&gt;
	&lt;point num="left-left"/&gt;
      &lt;/reference&gt;
      &lt;point num="right-right"/&gt;
      &lt;move distance="lc-vert-curve"&gt;
	&lt;point num="right-left"/&gt;
      &lt;/move&gt;
    &lt;/move&gt;
&lt;!-- width of character
    &lt;push&gt;57&lt;/push&gt;
    &lt;command name="SRP0"/&gt;
    &lt;push&gt;49 1&lt;/push&gt;
    &lt;command name="CALL"/&gt;
    &lt;push&gt;0&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;
--&gt;</pre>
  <p>
    We'll address two more details before testing the code. First, the
    FontForge auto-instructor regulates the left sidebearing with an
    MDRP instruction:
  </p>
  <pre>
    &lt;push&gt;63&lt;/push&gt;
    &lt;command name="MDAP" modifier="rnd"/&gt;
    &lt;push&gt;15&lt;/push&gt;
    &lt;command name="MDRP" modifier="rp0,rnd,white"/&gt;</pre>
  <p>
    This is the equivalent of the following:
  </p>
  <pre>
    &lt;move&gt;
      &lt;point num="left-sidebearing"/&gt;
      &lt;move&gt;
        &lt;point num="left-left"/&gt;
      &lt;/move&gt;
    &lt;/move&gt;</pre>
  <p>
    But Junicode uses a control value to regulate this distance. We
    can revise the code very simply, by adding the control value and
    changing MDRP to MIRP.
  </p>
  <pre>
    &lt;push&gt;63&lt;/push&gt;
    &lt;command name="MDAP" modifier="rnd"/&gt;
    &lt;push&gt;15 b-left-side&lt;/push&gt;
    &lt;command name="MIRP" modifier="rp0,rnd,white"/&gt;</pre>
  <p>
    Or we could replace the code (omitting to touch the
    left-sidebearing point, since this is unnecessary):
  </p>
  <pre>
    &lt;move distance="b-left-side"&gt;
      &lt;reference&gt;
        &lt;point num="left-sidebearing"/&gt;
      &lt;reference&gt;
      &lt;point num="left-left"/&gt;
    &lt;/move&gt;</pre>
  <p>
    Junicode also uses a control value to regulate standard vertical
    stems, and so we can make a similar change to the way the
    auto-instructor regulates the distance between <tt>left-left</tt>
    and <tt>left-right</tt>. We'll just change this:
  </p>
  <pre>
    &lt;push&gt;57&lt;/push&gt;
    &lt;command name="MDRP" modifier="min,rnd,black"/&gt;</pre>
  <p>
    to this:
  </p>
  <pre>
    &lt;push&gt;57 lc-vert-stem&lt;/push&gt;
    &lt;command name="MIRP" modifier="min,rnd,black"/&gt;</pre>
  <p>
    We'll just use <a href="xinclude.html">XInclude</a> to include the
    revised instructions in the font programming and compile (just
    <b>b</b> and <b>uni0180</b>, since we haven't got all day). Since
    we're feeling confident, we'll use the <tt>-f</tt> option to pipe
    Xgridfit's output to FontForge:
  </p>
  <pre>
    $ xgridfit -g b+bbar -f Junicode-Regular.xgf</pre>
  <p>
    Here is the result from <tt>Junicode-Regular.ttf</tt> as viewed in
    FontForge, with <b>b</b> again for comparison:
  </p>
  <table>
    <tr>
      <td>
	<img alt="hand-instructed b" src="b-hinted.png"/>
      </td>
      <td>
	<img alt="bbar auto-instructed" src="bbar-revised.png"/>
      </td>
    </tr>
  </table>
  <p>
    It might have been just as easy to copy the program for <b>b</b>
    and edit it; but editing an auto-instructed glyph will usually be
    quick and very often the easiest thing to do.
  </p>
</div>
</body>
</html>
